import {basicTypes, CheckerFunc, ITypeSuite, TFunc, TIface, TType} from "./types";
import {ErrorContext, NoopContext} from "./util";

export interface ICheckerSuite {
  [name: string]: Checker;
}

/**
 * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines
 * them into a suite of interface checkers. If a type is used by name, that name should be present
 * among pass-in type suites.
 *
 * The returned object maps type names to Checker objects.
 */
export function createCheckers(...typeSuite: ITypeSuite[]): ICheckerSuite {
  const fullSuite: ITypeSuite = Object.assign({}, basicTypes, ...typeSuite);
  const checkers: ICheckerSuite = {};
  for (const suite of typeSuite) {
    for (const name of Object.keys(suite)) {
      const ttype = suite[name];
      checkers[name] = new Checker(fullSuite, ttype);
    }
  }
  return checkers;
}

/**
 * Checker implements validation of objects, and also includes accessors to validate method calls.
 * Checkers should be created using `createCheckers()`.
 */
export class Checker {
  private props: Map<string, TType> = new Map();
  private checkerFunc: CheckerFunc;
  private strictCheckerFunc: CheckerFunc;

  // Create checkers by using `createCheckers()` function.
  constructor(private suite: ITypeSuite, private ttype: TType) {
    if (ttype instanceof TIface) {
      for (const p of ttype.props) {
        this.props.set(p.name, p.ttype);
      }
    }
    this.checkerFunc = this.ttype.getChecker(suite, false);
    this.strictCheckerFunc = this.ttype.getChecker(suite, true);
  }

  /**
   * Check that the given value satisfies this checker's type, or throw VError.
   */
  public check(value: any): void { return this._doCheck(this.checkerFunc, value); }

  /**
   * Check that the given value satisfies this checker's type strictly. This checks that objects
   * and tuples have no extra members. Note that this prevents backward compatibility, so usually
   * a plain check() is more appropriate.
   */
  public strictCheck(value: any): void { return this._doCheck(this.strictCheckerFunc, value); }

  /**
   * If this checker is for an interface, returns a Checker for the type required for the given
   * property of this interface.
   */
  public getProp(prop: string): Checker {
    const ttype = this.props.get(prop);
    if (!ttype) { throw new Error(`Type has no property ${prop}`); }
    return new Checker(this.suite, ttype);
  }

  /**
   * If this checker is for an interface, returns a Checker for the argument-list required to call
   * the given method of this interface. E.g. if this Checker is for the interface:
   *    interface Foo {
   *      find(s: string, pos?: number): number;
   *    }
   * Then methodArgs("find").check(...) will succeed for ["foo"] and ["foo", 3], but not for [17].
   */
  public methodArgs(methodName: string): Checker {
    const tfunc: TFunc = this._getMethod(methodName);
    return new Checker(this.suite, tfunc.paramList);
  }

  /**
   * If this checker is for an interface, returns a Checker for the return value of the given
   * method of this interface.
   */
  public methodResult(methodName: string): Checker {
    const tfunc = this._getMethod(methodName);
    return new Checker(this.suite, tfunc.result);
  }

  /**
   * If this checker is for a function, returns a Checker for its argument-list.
   */
  public getArgs(): Checker {
    if (!(this.ttype instanceof TFunc)) { throw new Error("getArgs() applied to non-function"); }
    return new Checker(this.suite, this.ttype.paramList);
  }

  /**
   * If this checker is for a function, returns a Checker for its result.
   */
  public getResult(): Checker {
    if (!(this.ttype instanceof TFunc)) { throw new Error("getResult() applied to non-function"); }
    return new Checker(this.suite, this.ttype.result);
  }

  /**
   * Actual implementation of check() and strictCheck().
   */
  private _doCheck(checkerFunc: CheckerFunc, value: any): void {
    const noopCtx = new NoopContext();
    if (!checkerFunc(value, noopCtx)) {
      const errorCtx = new ErrorContext();
      checkerFunc(value, errorCtx);
      throw new Error(errorCtx.getErrorMessage());
    }
  }

  private _getMethod(methodName: string): TFunc {
    const ttype = this.props.get(methodName);
    if (!ttype) { throw new Error(`Type has no property ${methodName}`); }
    if (!(ttype instanceof TFunc)) { throw new Error(`Property ${methodName} is not a method`); }
    return ttype;
  }
}
